## Виджеты

Виджет - это плагин с визуальной частью, представляющей собой прямоугольный блок в конкретном месте в UI МоегоСклада. 
Содержимое блока определяется приложением.

### FAQ по виджетам

**Куда сейчас можно встраивать виджеты?**

На данный момент для встраивания виджетов доступны страницы:

- Контрагент - новая карточка (_entity.counterparty.edit_)
- Контрагент - старая карточка (скоро перестанет поддерживаться) (_entity.counterparty.view_)
- Заказ покупателя (_document.customerorder.edit_)
- Отгрузка (_document.demand.edit_)
- Счет покупателю (_document.invoiceout.edit_)
- Заказ на производство (_document.processingorder.edit_)
- Заказ поставщику (_document.purchaseorder.edit_)
- Счет поставщика (_document.invoicein.edit_)
- Приемка (_document.supply.edit_)
- Розничная продажа (_document.retaildemand.edit_)
- Входящий платеж (_document.paymentin.edit_)
- Исходящий платеж (_document.paymentout.edit_) 
- Приходный ордер (_document.cashin.edit_)
- Расходный ордер (_document.cashout.edit_) 

Во всех точках расширения виджеты имеют одинаковый функционал.

Если у пользователя установлены сразу несколько приложений с виджетами, встроенными на одну
страницу МС, то отобразятся все виджеты в порядке, соответствующем расположению родительских 
приложений на витрине. В новом редакторе контрагентов пользователь может сам поменять порядок 
отображения виджетов.

Список доступных для модернизации страниц (точек расширения) будет активно дополняться. 

**Хочу встроить виджет в точку МоегоСклада, которой нет в списке - что делать?**

Если вы хотите встроить виджет в какую-то точку МоегоСклада, но её пока нет в списке доступных точек расширения -
 обращайтесь с предложением 
в Telegram или по электронной почте, мы всегда открыты для таких запросов.


**Какими могут быть виджеты:**

Сейчас можно создать только виджеты с  

- фиксированной шириной: 416px - для всего виджета (с рамкой), 384px - для рабочей области (iframe, определяемый
приложением).
- фиксированной высотой: задается в дескрипторе.

Планируется реализация поддержки двух режимов отображения виджетов:

- развернутая форма (полная) - **реализована для всех точек расширения**
- свернутая форма (краткая) - пока реализована только в новом редакторе контрагентов.


### Жизненный цикл виджета

Виджет начинает отображаться на странице только после перехода приложения в статус **Activated**.
Если приложение предполагает настройку и статус **SettingsRequired** - виджет отобразится 
после настройки приложения.

При первом открытии страницы с виджетом (в рамках одной вкладки браузера) cистема МоегоСклада 
загружает виджет по HTTP GET-запросом по URL'у, указанному в теге sourceUrl. При этом система 
генерирует и передает GET-параметром одноразовый contextKey, по которому виджет получает текущий 
контекст пользователя  через [Vendor API](#blok-vendorapi).

Прочие данные передаются при помощи [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) в первом и последующих открытиях виджета.

В частности, при каждом открытии виджета система МоегоСклада отображает ранее загруженный iframe 
виджета (без повторной загрузки с сервера вендора) и через [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) передает 
в iframe этого виджета сообщение `Open`.

Без дополнительных настроек виджет отображает содержимое сразу, как только получает 
сообщение `Open`, даже если еще не успел обновить отображаемую информацию. 

В случае, если виджет поддерживает протокол **open-feedback**, система не отображает 
 содержимое виджета сразу, а ждет ответного сообщения от виджета о готовности. 
 До этого момента внутри виджета отображается заглушка. Когда виджет готов, он 
 отправляет сообщение  `OpenFeedback`, после чего система полностью открывает 
 виджет пользователю.
 
 При сохранении страницы с виджетом, если виджет, который находится на экране редактирования сущности, 
 поддерживает протокол **save-handler**, то он оповещается о факте сохранения объекта пользователем, 
 получая сообщение `Save`.

Если виджет поддерживает протокол **dirty-state**, он (виджет) может сообщить хост-окну, 
что в виджете есть несохраненные изменения. Для этого виджет отправляет хост-окну 
сообщение `SetDirty`. Виджет может отправить хост-окну сообщение `ClearDirty`,
после чего диалог подтвержения закрытия окна не будет появляться (если, конечно, 
отсутствуют несохраненные изменения в самом UI МоегоСклада или в других виджетах).

Внутренний dirty-флаг для виджета в хост-окне сбрасывается при открытии
(при отправке сообщения `Open`) - т.е. хост-окно считает, что в виджете нет несохраненных изменений.
 
 Поддержку виджетом протоколов **open-feedback**, **save-handler**, **dirty-state** необходимо указать в [дескрипторе](#deskriptor-prilozheniq) 
  приложения.

### Как работают виджеты

#### Описание конфигурации виджетов приложения в дескрипторе

Виджеты доступны для серверных приложений с дескриптором версии v2. 

Пример дескриптора приложения с виджетом в новой карточке контрагента расположен в правой части экрана.

> Дескриптор приложения с виджетом в новой карточке контрагента


```xml
   <ServerApplication xmlns="https://online.moysklad.ru/xml/ns/appstore/app/v2"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="https://online.moysklad.ru/xml/ns/appstore/app/v2
         https://online.moysklad.ru/xml/ns/appstore/app/v2/application-v2.xsd">
       <iframe>...</iframe>
       <vendorApi>...</vendorApi>
       <access>...</access>
       <widgets>
           <entity.counterparty.edit>
               <sourceUrl>https://b2b.moysklad.ru/widget/counter-party</sourceUrl>
               <height>
                   <fixed>28px</fixed>
               </height>
               <supports>
                   <open-feedback/>
                   <save-handler/>
               </supports>
                <uses>
                    <good-folder-selector/>
                </uses>
           </entity.counterparty.edit>
       </widgets>
   </ServerApplication>
```

Подробнее со структурой дескриптора для приложения с виджетом можно ознакомиться в
разделе [Дескриптор приложений](#deskriptor-prilozheniq).

В результате после установки и настройки приложения пользователем виджет отображается 
на карточке контрагента:

![useful image](widget-counterparty-page.png)

#### Загрузка виджета на странице

Виджет на странице загружается в iframe по URL, указанному в теге 
`<sourceUrl>...</sourceUrl>` виджета в [дескрипторе приложения](#deskriptor-prilozheniq).

Ширина содержимого виджета одинакова для виджетов всех приложений и равна 400px, 
а высота содержимого виджета статически указывается разработчиком в дескрипторе 
приложения (в данном примере 61px).

![useful image](widget-size.png)

Так же, как и для основного iframe-приложения, виджету GET-параметром передается 
`contextKey`, по которому через [Vendor API](#blok-vendorapi) можно получить информацию о текущем 
пользователе.

Пока происходит загрузка виджета - отображается ненавязчивый лоадер.
#### Кэширование виджетов

Система виджетов в МоемСкладе реализована таким образом, чтобы, по-возможности, 
загрузить виджет только один раз при первом открытии страницы с виджетом 
(в рамках одной вкладки браузера) и далее кэшировать iframe c загруженном в него
виджетом, переиспользуя его во всех последующих (в рамках одной вкладки
браузера) открытиях страницы с виджетом.

Несмотря на стремление к идеальному кэшированию - оно не гарантировано. 
То есть хост-окно может:

- физически создать несколько экземпляров iframe’ов для одной и той же 
точки расширения в рамках одной вкладки браузера (по тем или иным техническим 
причинам), причем эти экземпляры могут существовать одновременно
- не кэшировать iframe-виджета после загрузки

#### Открытие виджета

При открытии пользователем страницы с виджетом хост-окно отображает iframe
 виджета (только что загруженный или ранее закэшированный) и передает в
этот iframe виджета сообщение `Open` через [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).

Пример сообщения `Open` cм. в правой части экрана.
> Сообщение Open

```json
    {
      "name": "Open",
      "messageId": 12345,
      "extensionPoint": "entity.counterparty.edit",
      "objectId": "8e9512f3-111b-11ea-0a80-02a2000a3c9c",
      "displayMode": "expanded"
    }
```


Здесь `objectId` - это в данном случае идентификатор контрагента, так как 
точка расширения `entity.counterparty.edit`. 

Виджет при получении сообщения `Open` может, например, обратиться на сервер 
за данными для указанного объекта `objectId` и отобразить их пользователю.

#### Протокол обратной связи при открытии виджета

По умолчанию при открытии закэшированного виджета его содержимое отображается сразу.

Если виджет при открытии делает обращение к серверу, то может быть видна 
небольшая задержка и в это время будет отображается прежнее состояние/содержание 
виджета (например, данные для прошлого контрагента).

Протокол обратной связи позволяет виджету явно сообщить хост-окну в какой именно 
момент отобразить содержимое виджета. До этого содержимое виджета будет закрыто 
ненавязчивым лоадером:

![useful image](loader-in-widget.png)

> Тег дополнительных протоколов supports с протоколом open-feedback


```xml
    <supports>
        <open-feedback/>
    </supports>
```

Для переключения хост-окна на использование протокола обратной связи при открытии виджета 
в дескрипторе для виджета надо явно указать поддержку дополнительного протокола **open-feedback**. Пример
тега дополнительных протоколов supports с указанным в нем протоколом **open-feedback** см. в правой части экрана.



Виджет передает сообщение `OpenFeedback` хост-окну в качестве сигнала готовности содержимого 
виджета для отображения пользователю. Пример сообщения  `OpenFeedback` - в правой части экрана.

> Cообщение OpenFeedback

```json 
{
  "name": "OpenFeedback",
  "correlationId": 12345
}
```

Здесь `correlationId` содержит значение `messageId` ранее полученного сообщения `Open`.

Хост-окно, получив сообщение `OpenFeedback`, отображает содержимое виджета пользователю 
(убирает ненавязчивый лоадер).

#### Сохранение пользователем редактируемого объекта

Хост-окно может оповещать виджет о факте сохранения редактируемого объекта. 
Для этого в дескрипторе для виджета нужно объявить поддержку опционального протокола **save-handler**.

  > Тег дополнительных протоколов supports с протоколом save-handler
  
  ```xml
      <supports>
          <save-handler/>
      </supports>
  ```
 
 Хост-окно отправляет виджету сообщение `Save` (через [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage)) 
 при сохранении редактируемого объекта после сохранения объекта в БД (то есть на момент получения 
 виджетом сообщения Save сохраненное состояние объекта уже доступно через JSON API).
 
 Сохранение редактируемого объекта инициируется пользователем:
 
 - при явном нажатии на кнопку “Сохранить”, в том числе при сохранении объекта без фактического внесения изменений
 
 - при покидании объекта и его явном сохранении через диалог подтверждения сохранения 
 изменений, в том числе при листании кнопками-стрелочками на соседние объекты
 
 - при автоматическом сохранении изменений закрываемого объекта (например, при создании связанного 
 документа Отгрузки из Заказа покупателя)
 
 Протокол **save-handler** не поддерживается для точки `entity.counterparty.view`.

 Пример сообщения `Save` cм. в правой части экрана.
 
 > Сообщение Save
 
 ```json
     {
       "name": "Save",
       "messageId": 32109,
       "extensionPoint": "entity.counterparty.edit",
       "objectId": "8e9512f3-111b-11ea-0a80-02a2000a3c9c"
     }
 ```

#### Признак несохраненного состояния виджета

> Тег дополнительных протоколов supports с протоколом dirty-state
  
```xml
  <supports>
      <dirty-state/>
  </supports>
```
Хост-окно поддерживает подтверждение закрытия окна пользователем, если он изменил данные 
в форме виджета, но не сохранил их. Для этого в дескрипторе для виджета 
нужно объявить поддержку опционального протокола **dirty-state**.

 
> Сообщение SetDirty

```json
    {
      "name": "SetDirty",
      "messageId": 12,
      "openMessageId": 7
    }
```
После внесения пользователем изменений в виджете, он отправляет хост-окну сообщение `SetDirty`. 
Пример сообщения SetDirty - в правой части экрана.
Здесь openMessageId содержит значение messageId ранее полученного сообщения Open.

Система учитывает, что в виджете есть несохраненные изменения. Далее, если пользователь нажимает кнопку “Закрыть“ (или другим способом пытается уйти с формы редактирования), 
система отображает диалог подтверждения сохранения изменений:

<img src=images/confirm-save-popup.png height="70%" width="70%">

> Сообщение ClearDirty

```json
    {
      "name": "ClearDirty",
      "messageId": 13
    }
```
Если виджет после отправки `SetDirty` отправляет хост-окну сообщение `ClearDirty`, 
то Система не учитывает данный виджет при отображении диалога подтверждения сохранения
 изменений (т.е., если отсутствуют прочие несохраненные изменения самого объекта 
 или в других виджетах - Система не запрашивает диалог подтверждения сохранения изменений 
при закрытии редактируемого объекта).

### Сервисы хост-окна
#### Селектор группы товаров

> Дескриптор с виджетом, использующим селектор группы товаров

```xml
<ServerApplication  xmlns="https://online.moysklad.ru/xml/ns/appstore/app/v2"             
                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"             
                    xsi:schemaLocation="https://online.moysklad.ru/xml/ns/appstore/app/v2      
                    https://online.moysklad.ru/xml/ns/appstore/app/v2/application-v2.xsd">
    <iframe>
        <sourceUrl>https://example.com/iframe.html</sourceUrl>
        <expand>true</expand>
    </iframe>
    <vendorApi>
        <endpointBase>https://example.com/dummy-app</endpointBase>
    </vendorApi>
    <access>
        <resource>https://online.moysklad.ru/api/remap/1.2</resource>
        <scope>admin</scope>
    </access>
    <widgets>        
        <entity.counterparty.edit>            
            <sourceUrl>https://example.com/widget.php</sourceUrl>            
            <height>                
                <fixed>150px</fixed>            
            </height>
            <uses>
                <good-folder-selector/>
            </uses>                  
        </entity.counterparty.edit>    
    </widgets>
</ServerApplication>
```

Позволяет виджетам приложений переиспользовать существующий в МоемСкладе селектор группы товаров с получением виджетом 
результата выбора пользователя.
Чтобы виджет начал поддерживать селектор в дескрипторе необходимо добавить блок:
```
<uses>
    <good-folder-selector/>
</uses>
```

Когда виджет отправляет хост-окну сообщение `SelectGoodFolderRequest`(через Window.postMessage), 
хост-окно запрашивает у пользователя выбор группы товаров, используя встроенный в МойСклад попап-селектор:
![useful image](good-folder-selector.png)

> Cообщение SelectGoodFolderRequest

```json 
{
  "name": "SelectGoodFolderRequest",
  "messageId": 12345
}
```

Здесь `messageId` - целочисленный идентификатор сообщения, уникальный в рамках текущего взаимодействия виджет - 
хост-окно. Назначается виджетом.

После совершения пользователем выбора группы товаров или отказа от него хост-окно передает виджету результат 
действий пользователя в сообщении `SelectGoodFolderResponse`. 

> Cообщение SelectGoodFolderResponse(Пользователь выбрал группу товаров, имеющую идентификатор 8e9512f3-111b-11ea-0a80-02a2000a3c9c)

```json 
{
  "name": "SelectGoodFolderResponse",
  "correlationId": 12345,
  "selected": true,
  "goodFolderId": "8e9512f3-111b-11ea-0a80-02a2000a3c9c"
}
```

Здесь:
+ `correlationId` - идентификатор соответствующего сообщения `SelectGoodFolderRequest`;
+ `selected` - признак наличия выбора;
+ `goodFolderId` - идентификатор выбранной группы товаров.

> Cообщение SelectGoodFolderResponse(Пользователь отменил выбор)

```json 
{
  "name": "SelectGoodFolderResponse",
  "correlationId": 12345,
  "selected": false
}
```
